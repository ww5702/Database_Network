# Database_Network
# OSI 7계층
하나의 표준 규격을 규정화하여 서로 다른 회사의 기계들 간 통신이 원활하게 이루어질 수 있도록 하는것   
7계층 응용계층   
실제로 사용자와 직접적으로 상호작용하는 계층   
ex) HTTP, FTP, DNS    
6계층 표현계층   
응용프로그램이나 네트워크를 위해 데이터를 표현하는 것   
데이터를 안전하게 전송하기 위해 암호화, 복호화, 파일 인코딩   
ex) JEPG   
5계층 세션계층   
서로 다른 기기, 컴퓨터, 서버 간 대화가 필요하면 세션을 만들어야하는데 여기서 처리   
데이터가 통신하기 위한 논리적인 연결을 담당   
TCP/IP 세션을 만들고 없애는 책임을 가진다   
ex) API, Socket   
4계층 전송계층   
데이터의 전송을 조율한다.   
보낼 데이터의 용량, 속도, 목적지 등을 처리   
목적지에 신뢰할 수 있는 데이터를 전달하도록 한다.   
ex) TCP: 신뢰성, 연결 지향성   
ex) UDP: 비신뢰성, 비연결성, 실시간   
3계층 네트워크계층   
여러 라우터를 통한 라우팅을 비롯한 패킷 전달   
라우팅, 흐름제어, 오류제어, 세그먼테이션등을 수행   
IP패킷, 라우터, IP   
2계층 데이터링크계층   
직접 연결된 노드 사이의 데이터 전송을 제공하고, 물리 계층의 오류도 수정한다.   
데이터에 MAC주소를 부여하고 에러검출, 재전송, 흐름제어를 진행   
ex) 브릿지, 스위치   
1계층 물리계층   
시스템의 전기적, 물리적표현   
전기적, 기계적인 특성을 이용하여 통신 테이블로 데이터를 전송하는 역할을 한다   
ex) 리피터, 케이블, 허브   

# TCP 
Transmission control protocol   
신뢰성 있는 데이터 전송을 지원하는 연결 지향형 프로토콜   
3-way handshake를 통해 연결을 설정하여 통신을 시작하고   
4-way handshake를 통해 연결을 해제한다.   
흐름제어, 혼잡제어, 오류제어를 통해 신뢰성을 보장하는 대신 UDP에 비해 속도가 느리다.   
데이터의 전송 순서를 보장하며 수신 여부를 확인할 수 있다.   
대부분의 HTTP통신, 이메일, 파일 전송   
패킷 = 인터넷 내에서 라우팅을 효율적으로 하기 위해 데이터를 여러 조각으로 나누는데 이때의 조각을 패킷이라고 한다.   

## 흐름제어
송신측과 수신측 사이의 데이터 처리 속도를 해결하기 위한 기법   
받는 쪽에서 처리되는 양보다 보내는양이 더 많으면 수신측의 큐를 넘어서 데이터가 손실될 수 있다.   

## 오류제어
오류 검출과 재전송을 포함   
ARP(Automatic Repeat Request) 기법을 사용, 프레임에 오류가 생기면 재전송   

## 혼잡제어
네트워크 혼잡을 피하기 위해 송신 측에서 데이터 전송   
속도를 제어한느것   
흐름 제어는 송신측과 수신측의 전송속도를 다루는데, 흐름제어는 라우터를 포함하여 보다 넓은 관점에서 문제를 다룬다.   

# UDP 
User Datagram Protocol   
데이터를 데이터그램(독립적인 관계를 지니는 패킷)단위로 처리한다.   
비연결형 프로토콜로 사전 연결 없이 데이터를 전달한다.   
하나의 메시지에서 분할된 각각의 패킷은 다른 경로로 재전송되고, 이러한 패킷에 순서를 부여하거나 재조립하지않는다.   
손상된 세그먼트에 대해 재전송을 하지 않는다.   
속도가 굉장히 빠르고, 네트워크 부하가 적지만, 신뢰성있는 데이터 전송을 보장하지 못한다.   

# 3-way handshake
클라이언트는 서버에 접속을 요청ㅇ하는 SYN(a) 패킷을 보낸다.   
서버는 클라이언트 SYN(a) 패킷의 요청 수락인 ACK 패킷과 포트를 열어달라는 SYN(b) 패킷을 보낸다.   
클라이언트는 수락패킷과 포트를 열어달라는 패킷을 받고 응답 ACK 패킷을 보낸다.   

# 4-way shaking
클라이언트는 서버에게 연결을 종료하겠다는 패킷(a)를 보내고   
서버는 클라이언트 요청에 대한 가능 응답으로 ACK패킷을 보내고, 처리해야할 통신이 끝날때까지 기다린다   
서버가 처리해야할 통신이 끝나면 서버 역시 연결을 종료하겠다는 패킷(b)을 보낸다   
클라이언트는 패킷(b)에 대한 수락으로 ACK패킷을 보낸다.   
클라이언트의 ACK 패킷을 받는 서버는 소켓 연결을 닫고, 서버로부터 아직 받지 않은 데이터를 대비하여 기다리는 과정을 거친다.   

# 대칭키와 공개키
## 대칭키 암호화
암호화에 사용되는 키와 복호화에 사용되는 키가 동일한 암호화 기법이다   
사용자가 모두 키를 가지고 있어야 한다   
키 전달 및 관리에 어려움이 있지만, 속도가 빠르다   
## 공개키
암호화에 사용하는 키와 복호화에 사용하는 키가 다르다 (비대칭키 암호화)라고도 한다.   
public key로 암호화하는경우 = data의 보안에 중점을 둔다.   
private key로 암호화하는경우 = 인증과정에 중점을 둔다   
키 길이가 길고 느리고 복잡하다.   

# HTTP, HTTPS
## HTTP   
웹 서버와 클라이언트 간의 문서를 교환하기 위한 통신 규약   
TCP/IP 기반   
비연결 지향 - 요청에 대한 응답의 데이터를 전송한 후 연결을 종료한다.   
단방향성 - 클라이언트의 요청에 대한 응답이기 때문에 서버가 먼저 응답하지 않는다.   
문제점 - 암호화하지 않은 통신이기 때문에 도청이 가능하다. 위장과 변조가 가능하다 즉 안전성이 낮다.   

## HTTPS 
HTTP의 문제를 해결하기 위한 방법   
SSL이라는 프로토콜을 추가한다.   
HTTP는 TCP와 직접 통신했지만 HTTPS에서는 HTTP -> SSL -> TCP 이렇게 거쳐서 통신한다.   
대칭키 암호화 방식과, 공개키 암호화 방식을 모두 사용한다.   

